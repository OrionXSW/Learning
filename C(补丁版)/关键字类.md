# volatile

这个关键字能让编译器每次访问被修饰变量时,不敢优化,每次都从内存里读取,不敢偷懒,把这个变量认真对待

一般情况下,你创建变量后,内存便有了该变量的一席之地,CPU读取这个变量后,要是没有volatile关键字修饰,CPU就会在它附近的寄存器中把这个值的副本(或者说同名同姓,跟个投影一样)存入,这个叫缓存(准确来说叫寄存器副本),这样可以提高运行效率,那么问题就来了,当变量在中断中被修改后,这个副本并不会改变,CPU仍然使用该副本的值,这就导致程序在逻辑上成立,现实情况却不对劲
当然了,这个和编译器的优化等级有关,优化等级为零,也就是调试模式时,有没有这个玩意也无关紧要,CPU都会从内存里读取变量的值,但当优化等级上来了,嘿嘿,就会搞事情了,这样的情况会让你非常难找到问题来源,所以**要是一个值需要跨主函数,中断,事件,**硬件寄存器**使用,一定要加个volatile**
还有对于不执行任何动作,对程序结果没有任何改变的循环,也需要加个volatile

for(volatile int i = 0; i  < 100; i++);	喏,这就是个软延时循环,仅为拖短短一点时间
对了,优化等级越高,执行效率越高噢


**凡是可能被你的代码流程之外的力量改变的变量，都必须加 `volatile`。”**

这股“外部力量”包括：

* **中断服务程序 (ISR)**
* **硬件本身 (硬件寄存器)**
* **其他核的CPU (多核系统)**
* **DMA控制器**

就像上面说的一样,无论是啥,会自己改本值或会触发中断而改变的,都要加volatile,以保证变量的值是实时的值
