# 冒泡排序

1.先把大的排到后面,次大的排到后面,排到最后就是第一个和第二个对比了

```
// 泛用冒泡排序函数模板
// arr: 数组指针
// n:   数组长度
void bubble_sort(float arr[], int n) {
    int i, j;
    float temp;
    for (i = 0; i < n - 1; i++) {         // 外层循环：控制排序轮次，共 n-1 轮:看一共有多少个数字
        for (j = 0; j < n - 1 - i; j++) { // 内层循环：每轮进行 n-1-i 次比较
            if (arr[j] > arr[j + 1]) {    // 如果前面的元素比后面大，则交换
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}

```

冒泡排序的生动过程

想象一下水里的一串气泡，最大的气泡会最先冒到水面。

1. **第一轮（i=0）**：内层循环 `j`从 `0`到 `n-2`（因为比较的是 `j`和 `j+1`），对所有 `n`个元素进行两两比较和交换。这一轮结束后，**最大的那个数肯定被“冒”到了最后一个位置（`index = n-1`）**。这个最大的数就位了，以后就不用再管它了。
2. **第二轮（i=1）**：因为最后一个位置已经是最大值，是排好序的了。所以内层循环 `j`只需要从 `0`到 `n-3`，对**前 `n-1`个**未排序的元素进行同样的操作。这轮结束后，**第二大的数就被“冒”到了倒数第二个位置**。
3. **第 i 轮**：以此类推，内层循环的范围就是 `j < n - 1 - i`。每一轮都会将一个未排序部分的最大值“冒”到它最终的位置，所以内层循环需要比较的范围就**减 1**。
4. **最后一轮（i = n-2）**：内层循环只需要比较最开始的两个元素 (`j=0`和 `j=1`)，

所以，内层循环的终止条件 `j < n - 1 - i`就是在实现这个“范围越来越小”的过程

# 变体1:选择排序

本质就是打擂台,大的全部排到后面,排到最后的有顺序了

```


arr[MAX] = {......};
uint8_t tmp = 0;
for(int i = 0; i < MAX - 1; i++)
{
	for(int j = 0; j < MAX; j++)
	{
		if(arr[j] > arr[j + 1])
		{
			tmp = arr[j];
			arr[j] = arr[j+1];
			arr[j+1] = tmp;
		}
	}

}
```

# 使用环境

简单排序在嵌入式里最常见于以下**需要从一组数据中提取一个代表值**的场景：

1. **数字滤波（你最熟悉的例子）**

   * **目的**：去除传感器读数中的偶然突变噪声（尖峰脉冲）。
   * **方法**：连续采样 N 次（比如5次），得到一个数组。对这个数组排序，取**中值**。
   * **为什么用排序**：因为最大值和最小值很可能是噪声，中值能更好地反映真实情况。
   * **环境**：你需要一个数组来缓存连续的采样值。
2. 控制系统或算法中

   * **目的**：从多个传感器或多个计算结果中，选择一个**中间值**或**最值**作为控制输入。
   * **例子**：四轴飞行器用多个传感器测姿，为了安全，可能会取中间值而不是平均值。或者，在显示系统参数时，从10次采样中取一个最大值来显示峰值。
3. 简单的用户界面（UI）操作

   * **目的**：对一组可供选择的项目（如菜单项、文件名列表）进行排序显示。
   * **环境**：你需要一个数组来存储这些项目的索引或字符串指针。

### 如何“创造环境”――核心就是使用数组

你说的“创造环境”，说白了就是：**当你预感到需要处理一组数据时，就果断地使用数组来存储它们。**

在你的超声波代码里，这个“环境”创造得非常典型：

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-c">// 1. “创造环境”：定义一个数组，用于存储一组原始数据
float measurements[5] = {0}; // 这就是你创造的“环境”！

// 2. 收集数据
for (int i = 0; i < 5; i++) {
    // ... 触发传感器并等待 ...
    measurements[i] = calculate_distance(); // 将每次测量的结果存入数组
}

// 3. 数据处理：此时，你就拥有了一个包含5个数据点的集合
//    接下来就可以对这个集合进行排序，从而应用算法
bubble_sort(measurements, 5); // 或者你用的选择排序

// 4. 提取结果：从处理后的集合中得到你想要的值
float median_distance = measurements[2]; // 取中值</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>

### 一个更简单的实战例子：求最大值

假设你要监控一个电源的输出电压，并记录其峰值。

<pre class="ybc-pre-component ybc-pre-component_not-math"><div class="hyc-common-markdown__code"><div class="hyc-common-markdown__code__hd"></div><pre class="hyc-common-markdown__code-lan"><div class="hyc-code-scrollbar"><div class="hyc-code-scrollbar__view"><code class="language-c">#define SAMPLE_TIMES 10

// 1. 创造环境：定义一个数组
uint16_t voltage_samples[SAMPLE_TIMES];

// 2. 收集数据（比如在定时器中断里采样）
void TIM_IRQHandler() {
    static int index = 0;
    voltage_samples[index] = read_ADC(); // 读取ADC值并存入数组
    index = (index + 1) % SAMPLE_TIMES;   // 循环覆盖
}

// 3. 在需要的时候（比如按下一个按键），处理数据
void print_max_voltage() {
    uint16_t max_voltage = voltage_samples[0];
    // 非常简单的“选择排序”思想：遍历数组找最大值
    for (int i = 1; i < SAMPLE_TIMES; i++) {
        if (voltage_samples[i] > max_voltage) {
            max_voltage = voltage_samples[i];
        }
    }
    printf("Max Voltage: %d mV\n", max_voltage);
}</code></div><div class="hyc-code-scrollbar__track"><div class="hyc-code-scrollbar__thumb"></div></div><div><div></div></div></div></pre></div></pre>


**自然地想到**：

> “我需要一组数据来解决这个问题 → 那我就该用一个数组来存它们 → 存起来之后我就可以对它们排序或找最值了”。
>
