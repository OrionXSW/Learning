# 按键检测

目标实现按键的长按,短按以及双击

# (轮询)方法1:常规方法(等待抬起)

```
if(HAL_GPIO_ReadPin(GPIOX,GPIO_PIN_X) == 1)
{
	HAL_Delay(20);		// 延时20ms 	按下消抖(必须要有) 
	if(HAL_GPIO_ReadPin(GPIOX,GPIO_PIN_X) == 1)
	{
		while(HAL_GPIO_ReadPin(GPIOX,GPIO_PIN_X) == 1);	// 等待抬起 阻塞之源
		HAL_Delay(20);	// 释放消抖 一般可以不用,但要是按键质量较差,最好加上.
		// 这里就写上
	}

	.
	.
	.
}
```

这个可以实现基本的短按检测,效果较好,但为阻塞式(使用到while),较为占用资源(卡程序)),所以能用别的就用别的

# 方法1优化

```

WKUP KEY2 KEY3 KEY4 分别被宏定义为读取对应引脚的电平信号函数 除了WKUP以外其余的常态都为高电平
uint8_t KEY_Scan(uint8_t mode)
{
	static uint8_t key_up = 1;	// 按键抬起检测
	if(mode)	key_up = 1;	// 支持连按

	if(key_up && (WKUP || !KEY2 || !KEY3 || !KEY4))
	{
		delay_ms(20);		// 按下消抖
		key_up = 0;		// 按键已按下

		if(WKUP)	return WKUP_PRESS;
		if(!KEY2)	return KEY2_PRESS;
		if(!KEY3)	return KEY3_PRESS;
		if(!KEY4)	return KEY4_PRESS;
	}
	else if (!WKUP && KEY2 && KEY3 && KEY4)	// 按键未按下状态
		key_up = 1;
	return 0; 	// 按键未按下一直返回0
}
这个没有用到while(),不会阻塞程序,能在轮询中使用,而不影响其他的功能

```

# (轮询)方法2:按键外部中断处理程序(系统滴答定时器实现无阻塞)

面对多按键,用结构体来将每个按键的状态或者参数分开记录(不是多按键就不用了,定义两个变量就行)

```
typedef struct{
   uint8_t  press_flag;     // 按下标志位
   uint32_t press_time;     // 按下时间戳
   uint8_t  is_processing;  // 正在处理标志位
  
}keystatus;
  
keystatus wkup = {0},key2 = {0},key3 = {0},key4 = {0};
/****************************************
*函数名     : keysolution
*函数功能   : 外部中断处理
*函数参数   : void
*函数返回值 : void
*函数描述   :
*******************************************/
void keysolution(void)
{
    if(wkup.press_flag && !(wkup.is_processing))
    {
        if(get_current_time() - wkup.press_time >= 20)   // 延时20ms
        {
            wkup.is_processing = 1;     // 正在处理 锁定防止重入
            if(WKUP == 1)
            {
                LED1TOGGLE;
                Serial1_Send_String((uint8_t *)"PRESS1\r\n");
            }
            wkup.press_flag = 0;  
            wkup.is_processing = 0;     // 释放锁定标志位
        }
    }
    if(key2.press_flag && !(key2.is_processing))
    {
        if(get_current_time() - key2.press_time >= 20)   // 延时20ms
        {
            key2.is_processing = 1;
            if(!KEY2)
            {
                LED2TOGGLE;
                Serial1_Send_String((uint8_t *)"PRESS2\r\n");
            }
            key2.press_flag = 0;
            key2.is_processing = 0;
        }
    }
    if(key3.press_flag && !(key3.is_processing))
    {
        if(get_current_time() - key3.press_time >= 20)   // 延时20ms
        {
            key3.is_processing = 1;
            if(!KEY3)
            {
                LED3TOGGLE;
                Serial1_Send_String((uint8_t *)"PRESS3\r\n");
            }
            key3.press_flag = 0;
            key3.is_processing = 0;
        }
    }
    if(key4.press_flag && !(key4.is_processing))
    {
        if(get_current_time() - key4.press_time >= 20)   // 延时20ms
        {
            key4.is_processing = 1;
            if(!KEY4)
            {
                LED4TOGGLE;
                Serial1_Send_String((uint8_t *)"PRESS4\r\n");
            }
            key4.press_flag = 0;
            key4.is_processing = 0;
        }
    }

}
/*******************按键中断Begin********************/
void EXTI0_IRQHandler(void)
{
	if(EXTI->PR & (1 << 0))	// 标志位挂起
	{
        if(WKUP)
        {
            wkup.press_flag = 1;                      // 按下了
            wkup.press_time = get_current_time();    // 获取当前时间  
        }
	}
	EXTI->PR |= 1 << 0;	// 结束挂起标志位
}
void EXTI2_IRQHandler(void)
{
	if(EXTI->PR & (1 << 2))	// 标志位挂起
	{
        if(!KEY2)
        {
            key2.press_flag = 1;
            key2.press_time = get_current_time();
        }
	}
	EXTI->PR |= 1 << 2;	// 结束挂起标志位
}
void EXTI3_IRQHandler(void)
{
	if(EXTI->PR & (1 << 3))	// 标志位挂起
	{
      if(!KEY3)
        {
            key3.press_flag = 1;
            key3.press_time = get_current_time();
        }
	}
	EXTI->PR |= 1 << 3;	// 结束挂起标志位
}
void EXTI4_IRQHandler(void)
{
	if(EXTI->PR & (1 << 4))	// 标志位挂起
	{
      if(!KEY4)
        {
            key4.press_flag = 1;
            key4.press_time = get_current_time();
        }
	}
	EXTI->PR |= 1 << 4;	// 结束挂起标志位
}
滴答定时器中断延时的部分看时钟系统文件夹/时钟初始化及systick部分
...
```

# 按键中断函数里的消抖
