# 按键检测

目标实现按键的长按,短按以及双击

# (轮询)方法1:常规方法(等待抬起)

```
if(HAL_GPIO_ReadPin(GPIOX,GPIO_PIN_X) == 1)
{
	HAL_Delay(20);		// 延时20ms 	按下消抖(必须要有) 
	if(HAL_GPIO_ReadPin(GPIOX,GPIO_PIN_X) == 1)
	{
		while(HAL_GPIO_ReadPin(GPIOX,GPIO_PIN_X) == 1);	// 等待抬起 阻塞之源
		HAL_Delay(20);	// 释放消抖 一般可以不用,但要是按键质量较差,最好加上.
		// 这里就写上
	}

	.
	.
	.
}
```

这个可以实现基本的短按检测,效果较好,但为阻塞式,较为占用资源(卡程序))

# (轮询)方法2:状态机设计(无需延时和while(),无阻塞)

使用计数的方法来模拟按键检测状态,双状态机:按下一个,释放一个(双重消抖))

面对多按键,用结构体来将每个按键的状态或者参数分开记录(不是多按键就不用了,定义两个变量就行)

```
typedef struct{
	uint16_t count;	// 计数的
	uint8_t flag;	// 标志位
}keystatus;

uint16_t num = 0;
static keystatus WKUP = {0};	// 声明静态变量,以保持实时状态
...
if(WKUP_R)	// 注: WKUP_R 为读取该按键电平的宏定义,其电路结构决定配置下拉输入
{
	if(WKUP.count < 20)	WKUP.count++;	// 可提高20的值来增强消抖
	if(WKUP.count == 10)	WKUP.flag = 1;	// 10 为按键触发灵敏度
}
else
{
	if(WKUP.count > 0) WKUP.count--;	// 释放
	if(WKUP.count == 0 && WKUP.flag == 1)
	{
			WKUP.flag = 0;
			num = 1;	// 属于该按键的编号(自己定)
	}
}
...
```

# 按键中断函数里的消抖
