# 按键检测

目标实现按键的长按,短按以及双击

# (轮询)方法1:常规方法(等待抬起)

```
if(HAL_GPIO_ReadPin(GPIOX,GPIO_PIN_X) == 1)
{
	HAL_Delay(20);		// 延时20ms 	按下消抖(必须要有) 
	if(HAL_GPIO_ReadPin(GPIOX,GPIO_PIN_X) == 1)
	{
		while(HAL_GPIO_ReadPin(GPIOX,GPIO_PIN_X) == 1);	// 等待抬起 阻塞之源
		HAL_Delay(20);	// 释放消抖 一般可以不用,但要是按键质量较差,最好加上.
		// 这里就写上
	}

	.
	.
	.
}
```

这个可以实现基本的短按检测,效果较好,但为阻塞式(使用到while),较为占用资源(卡程序)),所以能用别的就用别的

# 方法1优化

```

WKUP KEY2 KEY3 KEY4 分别被宏定义为读取对应引脚的电平信号函数 除了WKUP以外其余的常态都为高电平
uint8_t KEY_Scan(uint8_t mode)
{
	static uint8_t key_up = 1;	// 按键抬起检测
	if(mode)	key_up = 1;	// 支持连按

	if(key_up && (WKUP || !KEY2 || !KEY3 || !KEY4))
	{
		delay_ms(20);		// 按下消抖
		key_up = 0;		// 按键已按下

		if(WKUP)	return WKUP_PRESS;
		if(!KEY2)	return KEY2_PRESS;
		if(!KEY3)	return KEY3_PRESS;
		if(!KEY4)	return KEY4_PRESS;
	}
	else if (!WKUP && KEY2 && KEY3 && KEY4)	// 按键未按下状态
		key_up = 1;
	return 0; 	// 按键未按下一直返回0
}
这个没有用到while(),不会阻塞程序,能在轮询中使用,而不影响其他的功能

```

# (轮询)方法2:状态机设计(无需延时和while(),无阻塞)

使用计数的方法来模拟按键检测状态,双状态机:按下一个,释放一个(双重消抖))

面对多按键,用结构体来将每个按键的状态或者参数分开记录(不是多按键就不用了,定义两个变量就行)

```
typedef struct{
	uint16_t count;	// 计数的
	uint8_t flag;	// 标志位
}keystatus;

uint16_t num = 0;
static keystatus WKUP = {0};	// 声明静态变量,以保持实时状态
...
if(WKUP_R)	// 注: WKUP_R 为读取该按键电平的宏定义,其电路结构决定配置下拉输入
{
	if(WKUP.count < 20)	WKUP.count++;	// 可提高20的值来增强消抖
	if(WKUP.count == 10)	WKUP.flag = 1;	// 10 为按键触发灵敏度
}
else
{
	if(WKUP.count > 0) WKUP.count--;	// 释放
	if(WKUP.count == 0 && WKUP.flag == 1)
	{
			WKUP.flag = 0;
			num = 1;	// 属于该按键的编号(自己定)
	}
}
...
```

# 按键中断函数里的消抖
