# 任务

**任务就是：一段独立的、无限循环的、可以被操作系统调度和管理的程序代码**

注意: 独立 无限循环

# 任务的核心组成部分（它的“身份证”）

当一个任务被创建时，操作系统（FreeRTOS）会为它建立一个档案，叫做  **任务控制块（TCB - Task Control Block）** 。这个TCB就像任务的身份证，包含了管理这个任务所需的一切信息：

1. **任务函数** ：就是任务要执行的那段代码。它是一个永远不会返回的 `void` 函数，里面通常是一个 `while(1)` 无限循环。
2. **任务名称** ：一个字符串，方便我们调试和识别任务（比如 `"LED_Task"`, `"Sensor_Task"`）。
3. **任务堆栈（Stack）** ：

* 这是任务 **独有的“私人内存空间”** 。
* 用于存放函数调用时的局部变量、返回地址等信息。
* **非常重要！** 每个任务都有自己的堆栈，所以任务A的局部变量不会破坏任务B的变量，实现了隔离。分配足够的堆栈空间是关键，否则任务会崩溃。

   4.**任务优先级（Priority）** ：

* 一个数字，代表这个任务的“重要程度”。
* **优先级高的任务**可以**抢占（Preempt）** 优先级低的任务。就像急诊病人可以插队一样。
* 相同优先级的任务会 **轮流执行（时间片轮转）** 。

   5.**任务状态（State）** ：任务在任何时刻都处于以下状态之一，这是理解任务如何运行的关键：

* **运行态（Running）** ：任务正在CPU上执行。 **任何时候，只有一个任务处于此状态** （单核CPU）。
* **就绪态（Ready）** ：任务已经准备好，随时可以运行，只是在等待CPU资源（等待调度器选中它）。
* **阻塞态（Blocked）** ：任务在 **等待某个事件** （比如延时时间到、收到一个信号、收到一条消息）。这是 **提高CPU效率的关键** ！任务在阻塞态不消耗CPU时间。
* **挂起态（Suspended）** ：任务被强制暂停，调度器永远不会运行它，除非手动把它恢复。
* 
* **删除态（Deleted）** ：任务已被删除，等待操作系统清理其资源。






  # 理解

  :首先创建一个任务前,要写任务的执行函数,这是解决要干什么的问题,创建任务后,系统会在内存(堆)里分配两个空间给任务:一个存TCB的(任务的各种信息,名字,状态,栈指针等等),另一个是栈空间,这里就引入一个概念:任务句柄,这玩意是个指向TCB的指针,可以凭借这玩意来访问读取或修改TCB的内容,从而改变任务的信息,在创建任务的过程中,将一个指向任务句柄的指针当作参数存入任务创建函数里面(这个参数其实就是任务句柄的地址,知道地址后就可以控制任务句柄了),从而系统可以根据任务句柄指针来进行访问,读取或修改任务,嗯,现在就到切换任务的时候,切换任务时,系统会将相关寄存器的数据压入前一个任务的栈中,以保护现场,然后轮到新任务时,系统会把该任务栈空间的值取出,恢复使用环境(又称上下文切换)从而实现任务切换.
  其实创建任务和任务切换概括起来就是1.创建与任务相关的东西(任务函数,优先级,栈空间大小,栈指针,当前任务状态,),在内存(堆)上分配两个空间(一个给TCB,一个给栈,后面一个自己决定),然后把任务控制权(任务句柄指针)给系统2.保留前一个任务的现场,载入后一个任务的环境

```
void TaskA(void *pvParameter)
{

	while(1)
	{

	}

}
```
