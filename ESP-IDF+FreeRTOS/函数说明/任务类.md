# 任务句柄和任务句柄指针补充

在 FreeRTOS 中，每创建一个任务，内核都会在内存中为这个任务分配两块东西：

1. **任务控制块（TCB）** ：一个数据结构，里面记录了任务的所有信息，如优先级、状态、栈指针、当前状态等。这是内核管理任务的核心。
2. **任务栈（Stack）** ：一块内存空间，用于存放任务运行时局部变量、函数调用地址等。

**任务句柄（`TaskHandle_t`）** 的本质就是一个 **指向任务控制块（TCB）的指针** 。内核通过这个指针就能找到这个任务的所有信息。

任务句柄指针(TaskHandle_t *)	就是上面任务句柄的地址,知道了任务句柄的地址,系统具备了控制任务的能力

# FreeRTOS 任务相关函数详解

### 1. 任务创建函数

#### `xTaskCreate()` - 创建任务

这是最基础也是最常用的任务创建函数。

**c**

```
BaseType_t xTaskCreate(
    TaskFunction_t pvTaskCode,     // 任务函数指针 创建一个任务函数后,把任务函数名放进去
    const char * const pcName,     // 任务名称（字符串）
    configSTACK_DEPTH_TYPE usStackDepth, // 堆栈大小（以字为单位）一般2048就行
    void * const pvParameters,     // 传递给任务函数的参数
    UBaseType_t uxPriority,        // 任务优先级		对于普通的任务 设为1就行
    TaskHandle_t * const pvCreatedTask // 任务句柄指针
);
```

**参数详解：**

* `pvTaskCode`: 指向任务函数的指针，函数形式应为 `void vTaskFunction(void *pvParameters)`
* `pcName`: 描述性任务名称，用于调试，最大长度由 `configMAX_TASK_NAME_LEN` 定义
* `usStackDepth`: 堆栈大小， **单位是字（4字节）** 。例如 1024 = 4096字节
* `pvParameters`: 传递给任务的值，可以是任意类型的指针
* `uxPriority`: 优先级（0最低，`configMAX_PRIORITIES-1`最高）
* `pvCreatedTask`: 用于传出任务句柄，可用于后续引用该任务

**返回值：**

* `pdPASS`: 任务创建成功
* `pdFAIL`: 任务创建失败（通常是内存不足）

**示例：**

**c**

```
void myTask(void *pvParameters) {
    int task_id = (int)pvParameters;
    while(1) {
        printf("Task %d running\n", task_id);
        vTaskDelay(pdMS_TO_TICKS(1000));
    }
}

void app_main() {
    TaskHandle_t xHandle = NULL;
    xTaskCreate(myTask, "MyTask", 2048, (void*)1, 2, &xHandle);
}
```

#### `xTaskCreatePinnedToCore()` - 创建并绑定到指定核心

ESP32特有的函数，允许指定任务运行在哪个CPU核心上。

**c**

```
BaseType_t xTaskCreatePinnedToCore(
    TaskFunction_t pvTaskCode,
    const char * const pcName,
    const uint32_t usStackDepth,
    void * const pvParameters,
    UBaseType_t uxPriority,
    TaskHandle_t * const pvCreatedTask,
    const BaseType_t xCoreID // 核心ID：0, 1 或 tskNO_AFFINITY
);
```

**特殊参数：**

* `xCoreID`:
  * `0`: 绑定到Core 0
  * `1`: 绑定到Core 1
  * `tskNO_AFFINITY`: 不绑定，由调度器决定

---

### 2. 任务删除函数

#### `vTaskDelete()` - 删除任务

**c**

```
void vTaskDelete(TaskHandle_t xTaskToDelete);
```

**参数：**

* `xTaskToDelete`: 要删除的任务句柄
* 传入 `NULL` 表示删除当前任务自身

**重要提示：**

* 任务被删除后，其内存（栈和任务控制块）会被自动释放
* 任务可以在任何状态下被删除，包括删除自身
* 删除自身是常见的做法，特别是 `app_main`任务在创建完其他任务后

**示例：**

**c**

```
void taskToDelete(void *pvParameters) {
    // 任务执行一些工作...
    vTaskDelete(NULL); // 任务完成后删除自己
}

void app_main() {
    TaskHandle_t xHandle;
    xTaskCreate(taskToDelete, "TempTask", 2048, NULL, 1, &xHandle);
  
    // 创建完其他任务后，app_main删除自己
    vTaskDelete(NULL);
}
```

---

### 3. 任务延时函数

#### `vTaskDelay()` - 相对延时

**c**

```
void vTaskDelay(const TickType_t xTicksToDelay);
```

**参数：**

* `xTicksToDelay`: 要延时的tick数
* 使用 `pdMS_TO_TICKS()` 宏将毫秒转换为tick数

**特点：**

* 相对延时：从调用时刻开始计算延时
* 任务进入阻塞状态，让出CPU

**示例：**

**c**

```
vTaskDelay(pdMS_TO_TICKS(100)); // 延时100毫秒
```

#### `vTaskDelayUntil()` - 绝对延时（防漂移）

**c**

```
void vTaskDelayUntil(TickType_t * const pxPreviousWakeTime, 
                     const TickType_t xTimeIncrement);
```

**参数：**

* `pxPreviousWakeTime`: 指向存储上次唤醒时间的变量
* `xTimeIncrement`: 期望的周期（以tick为单位）

**特点：**

* 绝对延时：保证固定的执行周期，自动补偿任务执行时间
* 适合需要精确周期性的任务

**示例：**

**c**

```
void preciseTask(void *pvParameters) {
    TickType_t xLastWakeTime = xTaskGetTickCount();
    const TickType_t xFrequency = pdMS_TO_TICKS(100); // 100ms周期
  
    while(1) {
        // 执行任务工作...
        vTaskDelayUntil(&xLastWakeTime, xFrequency); // 精确100ms周期
    }
}
```

---

### 4. 任务优先级函数

#### `uxTaskPriorityGet()` - 获取任务优先级

**c**

```
UBaseType_t uxTaskPriorityGet(const TaskHandle_t xTask);
```

#### `vTaskPrioritySet()` - 设置任务优先级

**c**

```
void vTaskPrioritySet(TaskHandle_t xTask, UBaseType_t uxNewPriority);
```

**示例：**

**c**

```
// 获取当前任务优先级
UBaseType_t current_prio = uxTaskPriorityGet(NULL);

// 提高某个任务的优先级
vTaskPrioritySet(xHandle, current_prio + 1);
```

---

### 5. 任务控制函数

#### `vTaskSuspend()` - 挂起任务

**c**

```
void vTaskSuspend(TaskHandle_t xTaskToSuspend);
```

* 挂起的任务不再被调度，直到被恢复

#### `vTaskResume()` - 恢复被挂起的任务

**c**

```
void vTaskResume(TaskHandle_t xTaskToResume);
```

#### `vTaskSuspendAll()` - 挂起所有任务（除调用者外）

**c**

```
void vTaskSuspendAll(void);
```

* 挂起调度器，但不禁止中断
* 需要调用 `xTaskResumeAll()` 来恢复

#### `xTaskResumeAll()` - 恢复所有被挂起的任务

**c**

```
BaseType_t xTaskResumeAll(void);
```

---

### 6. 任务信息函数

#### `vTaskGetInfo()` - 获取任务信息

**c**

```
void vTaskGetInfo(TaskHandle_t xTask,
                  TaskStatus_t *pxTaskStatus,
                  BaseType_t xGetFreeStackSpace,
                  eTaskState eState);
```

#### `uxTaskGetStackHighWaterMark()` - 获取栈空间剩余量

**c**

```
UBaseType_t uxTaskGetStackHighWaterMark(TaskHandle_t xTask);
```

* 返回任务历史最小剩余栈空间（以字为单位）
* 重要用于检查栈溢出

**示例：**

**c**

```
// 检查栈使用情况
UBaseType_t high_water = uxTaskGetStackHighWaterMark(NULL);
printf("Minimum free stack: %d words\n", high_water);
```

---

### 7. 特殊函数

#### `xTaskGetCurrentTaskHandle()` - 获取当前任务句柄

**c**

```
TaskHandle_t xTaskGetCurrentTaskHandle(void);
```

#### `pcTaskGetName()` - 获取任务名称

**c**

```
char *pcTaskGetName(TaskHandle_t xTaskToQuery);
```

#### `xTaskGetTickCount()` - 获取系统时间戳

**c**

```
TickType_t xTaskGetTickCount(void);
```

---

## 最佳实践和建议

1. **堆栈大小选择** ：

* 简单任务：1-2KB（256-512字）
* 中等任务：2-4KB（512-1024字）
* 复杂任务：4-8KB（1024-2048字）
* 使用 `uxTaskGetStackHighWaterMark()` 监控实际使用情况

1. **优先级规划** ：

* 系统任务（如WiFi）：高优先级（5+）
* 用户关键任务：中优先级（3-4）
* 普通任务：低优先级（1-2）
* 避免过多的相同优先级任务

1. **错误处理** ：

* 总是检查 `xTaskCreate()` 的返回值
* 使用断言确保关键任务创建成功

1. **资源清理** ：

* 任务完成后应该删除自己
* `app_main` 在初始化完成后通常应该删除自己
